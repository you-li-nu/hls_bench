def _is_clock_signal(name: str):
    "heuristic to determine if a signal is a clock"
    return name.endswith("_clk")

def _is_reset_signal(name: str):
    "heuristic to determine if a signal is a reset"
    return name.endswith("_rst")

def _is_valid_signal(name: str):
    "heuristic to determine if a signal is a valid"
    return name.endswith("_vld")


class VerilogModule:
    """
    Interal representation of a verilog module.
    Assumes all fields to be fully constructed.
    """
    module_name: str
    start_line: int
    end_line: int
    port_end_line: int

    clock_input_name: str
    clock_enable_input_name: str
    reset_input_name: str
    normal_input_names: list[str]

    valid_output_name: str
    normal_output_names: list[str]

    name_to_width: dict[str, int]

    def __init__(self):
        self.normal_input_names = []
        self.normal_output_names = []
        self.name_to_width = {}


class VerilogFile:
    """
    Interal representation of a verilog file.
    The file is assumed to be generated by Vivado, thus neatly formatted.
    """
    raw_lines: list[str]
    "Lines of the verilog file without `\\n`."
    modules: list[VerilogModule]
    "A list of modules in the file."

    def __init__(self):
        self.raw_lines = []
        self.modules = []

    def read_from_file(self, path: str):
        "read/reload the verilog file from disk."
        self.raw_lines = []
        with open(path) as f:
            for line in f:
                assert line.endswith("\n")
                self.raw_lines.append(line[:-1])  # remove `\n`
        self.parse_modules()

    def parse_modules(self):
        "Fill up `self.modules` given `self.raw_lines`."
        self.modules = []
        curr_module = None
        for i, line in enumerate(self.raw_lines):
            if line.startswith("module "):
                curr_module = VerilogModule()
                curr_module.start_line = i
                curr_module.module_name = line.split()[1]
            elif line.startswith("endmodule"):
                curr_module.end_line = i
                self.modules.append(curr_module)
            elif line.startswith("input "):  # assume one line per input
                last_token = line.split()[-1]
                assert last_token.endswith(";")
                name = last_token[:-1]
                if _is_clock_signal(name):
                    curr_module.clock_input_name = name
                elif _is_reset_signal(name):
                    curr_module.reset_input_name = name
                elif name == CLK_ENABLE_SIGNAL_NAME:
                    curr_module.clock_enable_input_name = name
                else:
                    curr_module.normal_input_names.append(name)
                second_token = line.split()[1]
                if second_token.startswith("["):
                    assert second_token.endswith(":0]")
                    width = int(second_token[1:-3]) + 1
                    curr_module.name_to_width[name] = width
                else:
                    curr_module.name_to_width[name] = 1
            elif line.startswith("output "):  # assume one line per output
                last_token = line.split()[-1]
                assert last_token.endswith(";")
                name = last_token[:-1]
                if _is_valid_signal(name):
                    curr_module.valid_output_name = name
                else:
                    curr_module.normal_output_names.append(name)
                second_token = line.split()[1]
                if second_token.startswith("["):
                    assert second_token.endswith(":0]")
                    width = int(second_token[1:-3]) + 1
                    curr_module.name_to_width[name] = width
                else:
                    curr_module.name_to_width[name] = 1
            elif line.startswith(");"):
                curr_module.port_end_line = i

    def write_to_file(self, path: str):
        "Write the verilog file back to disk."
        with open(path, "w") as f:
            for line in self.raw_lines:
                f.write(line + "\n")


def remove_reset_signal(src: VerilogFile) -> VerilogFile:
    "Remove reset signal from every module in `src`, setting them to constant zero."
    dst = VerilogFile()
    dst.raw_lines.append("// Processed by function `remove_reset_signal` in `verilog_tricks.py`.")
    curr_module_index = 0
    curr_src_line_index = 0

    while curr_src_line_index < len(src.raw_lines):
        # start of a module:
        if curr_module_index < len(src.modules) and curr_src_line_index == src.modules[curr_module_index].start_line:
            m = src.modules[curr_module_index]
            while curr_src_line_index <= m.port_end_line:
                line = src.raw_lines[curr_src_line_index]
                if m.reset_input_name not in line:
                    dst.raw_lines.append(line)  # skip the reset input
                curr_src_line_index += 1
            while curr_src_line_index <= m.end_line:
                line = src.raw_lines[curr_src_line_index]
                if line.startswith("input ") and m.reset_input_name in line: 
                    dst.raw_lines.append(line.replace("input ", "wire "))  # change reset signal to wire
                    dst.raw_lines.append(f"assign {m.reset_input_name} = 1'b0;")  # assign reset to constant 0
                else:
                    dst.raw_lines.append(line)
                curr_src_line_index += 1
            curr_module_index += 1
        else: # outside of a module, just copy the lines:
            dst.raw_lines.append(src.raw_lines[curr_src_line_index])
            curr_src_line_index += 1
    dst.parse_modules()
    return dst


MERGED_VALID_SIGNAL_NAME = "merged_vld"
def merge_valid_signals(src: VerilogFile) -> VerilogFile:
    "Merge all valid signals into one. Assume there is only one module, I am lazy..."
    dst = VerilogFile()
    dst.raw_lines.append("// Processed by function `merge_valid_signals` in `verilog_tricks.py`.")
    m, = src.modules
    curr_src_line_index = 0

    while curr_src_line_index < len(src.raw_lines):
        # start of a module:
        if curr_src_line_index == m.start_line:
            valid_signal_names = []
            while curr_src_line_index < m.port_end_line:  # when loop ends, just right at the ");" line.
                line = src.raw_lines[curr_src_line_index]
                name = line.strip().strip(",")
                if name.endswith("(") or name.endswith(");") or len(name) == 0:  # non-name line, keep it
                    dst.raw_lines.append(line)
                elif name.endswith("_vld"):  # skip the line
                    valid_signal_names.append(name)
                else:
                    dst.raw_lines.append(f"{name},")
                curr_src_line_index += 1
            assert len(valid_signal_names) > 0
            if len(valid_signal_names) == 1:  # no need to process, early return...
                return src
            dst.raw_lines.append(MERGED_VALID_SIGNAL_NAME)
            yet_to_process_count = len(valid_signal_names)
            while curr_src_line_index <= m.end_line:
                line = src.raw_lines[curr_src_line_index]
                if line.startswith("output "):
                    tokens = line.strip(";").split()
                    if len(tokens) == 2 and tokens[1] in valid_signal_names:
                        # dst.raw_lines.append(line.replace("output ", "wire ")) seems wire cannot be assigned in block..
                        dst.raw_lines.append(line.replace("output ", "reg "))
                        yet_to_process_count -= 1
                    else:
                        dst.raw_lines.append(line)
                elif line.startswith("reg "):
                    tokens = line.strip(";").split()
                    if len(tokens) == 2 and tokens[1] in valid_signal_names:
                        pass # remove redundant regs; already declared as reg (originally "as wire")
                    else:
                        dst.raw_lines.append(line)
                else:
                    dst.raw_lines.append(line)
                if yet_to_process_count == 0:
                    dst.raw_lines.append(f"output {MERGED_VALID_SIGNAL_NAME};")
                    dst.raw_lines.append(f"assign {MERGED_VALID_SIGNAL_NAME} = {' & '.join(valid_signal_names)};")
                    yet_to_process_count -= 1
                curr_src_line_index += 1
        else: # outside of a module, just copy the lines:
            dst.raw_lines.append(src.raw_lines[curr_src_line_index])
            curr_src_line_index += 1
    dst.parse_modules()
    return dst


CLK_ENABLE_SIGNAL_NAME = "clk_enable"
def add_clk_enable_signal(src: VerilogFile) -> VerilogFile:
    "Add a clock enable signal to every module in `src`, as an alternative to clock gating."
    dst = VerilogFile()
    dst.raw_lines.append("// Processed by function `add_clk_enable_signal` in `verilog_tricks.py`.")
    curr_module_index = 0
    curr_src_line_index = 0

    while curr_src_line_index < len(src.raw_lines):
        # start of a module:
        if curr_module_index < len(src.modules) and curr_src_line_index == src.modules[curr_module_index].start_line:
            m = src.modules[curr_module_index]
            while curr_src_line_index < m.port_end_line:
                dst.raw_lines.append(src.raw_lines[curr_src_line_index])
                curr_src_line_index += 1
            dst.raw_lines[-1] = dst.raw_lines[-1] + ","   # fix port list
            dst.raw_lines.append(CLK_ENABLE_SIGNAL_NAME)  # add clk_enable signal to port list
            nested_level = 0
            in_always_block = False
            while curr_src_line_index <= m.end_line:      
                if curr_src_line_index == m.port_end_line + 1:
                    dst.raw_lines.append(f"input {CLK_ENABLE_SIGNAL_NAME};")  # add clk_enable signal as input
                line = src.raw_lines[curr_src_line_index]
                if line.startswith("always @ (posedge "):  # add clk_enable to every `always` block
                    assert m.clock_input_name in line and line.strip().endswith(") begin") and nested_level == 0
                    dst.raw_lines.append(line)
                    dst.raw_lines.append(f"if ({CLK_ENABLE_SIGNAL_NAME}) begin")
                    nested_level += 1
                    in_always_block = True
                else:
                    tokens = line.strip().split()
                    if "begin" in tokens:
                        nested_level += 1
                    if "end" in tokens:
                        nested_level -= 1
                        if nested_level == 0 and in_always_block:
                            dst.raw_lines.append("end")
                            in_always_block = False
                    dst.raw_lines.append(line)
                curr_src_line_index += 1
            assert nested_level == 0 and not in_always_block
            curr_module_index += 1
        else: # outside of a module, just copy the lines:
            dst.raw_lines.append(src.raw_lines[curr_src_line_index])
            curr_src_line_index += 1
    dst.parse_modules()
    return dst


def _wire_str(name: str, width_map: dict[str, int]) -> str:
    width = width_map[name]
    if width == 1:
        return name
    else:
        return f"[{width-1}:0] {name}"

UNSAFE_SINGAL_NAME = "unsafe_signal"
def construct_kairos(src_a: VerilogFile, src_b: VerilogFile, fast_slow_mode: bool) -> VerilogFile:
    "Constructs a product machine for equivalence checking in the Kairos fashion."
    dst = VerilogFile()
    dst.raw_lines.append("// Processed by function `construct_kairos` in `verilog_tricks.py`.")
    assert len(src_a.modules) == 1 and len(src_b.modules) == 1
    m_a, m_b = src_a.modules[0], src_b.modules[0]
    assert m_a.clock_input_name == m_b.clock_input_name
    assert m_a.valid_output_name == m_b.valid_output_name
    assert sorted(m_a.normal_input_names) == sorted(m_b.normal_input_names)
    assert sorted(m_a.normal_output_names) == sorted(m_b.normal_output_names)

    dst.raw_lines.append("// Machine A:")
    for line in src_a.raw_lines:
        if line.startswith("module "):
            line = f"module {m_a.module_name}_A ("  # rename module
        dst.raw_lines.append(line)
    dst.raw_lines.append("")
    dst.raw_lines.append("// Machine B:")
    for line in src_b.raw_lines:
        if line.startswith("module "):
            line = f"module {m_b.module_name}_B ("  # rename module
        dst.raw_lines.append(line)
    dst.raw_lines.append("")
    dst.raw_lines.append("// Product machine:")

    width_map = m_a.name_to_width
    normal_input_names = m_a.normal_input_names
    normal_output_names = m_a.normal_output_names
    clock_input_name = m_a.clock_input_name
    valid_output_name = m_a.valid_output_name

    ports = normal_input_names + [clock_input_name, UNSAFE_SINGAL_NAME]
    dst.raw_lines.append(f"module {m_a.module_name}_A_times_{m_b.module_name}_B ({', '.join(ports)});")
    for name in normal_input_names:
        dst.raw_lines.append(f"input {_wire_str(name, width_map)};")
    dst.raw_lines.append(f"input {clock_input_name};")
    dst.raw_lines.append(f"output {UNSAFE_SINGAL_NAME};")

    miter_names = []
    for name in normal_output_names:
        dst.raw_lines.append(f"wire {_wire_str(name, width_map)}_A;")
        dst.raw_lines.append(f"wire {_wire_str(name, width_map)}_B;")
        dst.raw_lines.append(f"wire {name}_eq;")
        dst.raw_lines.append(f"assign {name}_eq = {name}_A == {name}_B;")
        miter_names.append(f"{name}_eq")
    dst.raw_lines.append(f"wire {valid_output_name}_A;")
    dst.raw_lines.append(f"wire {valid_output_name}_B;")
    dst.raw_lines.append(f"wire {CLK_ENABLE_SIGNAL_NAME}_A;")
    dst.raw_lines.append(f"wire {CLK_ENABLE_SIGNAL_NAME}_B;")
    dst.raw_lines.append(f"assign {CLK_ENABLE_SIGNAL_NAME}_A = ~{valid_output_name}_A | {valid_output_name}_B;")
    if fast_slow_mode:
        dst.raw_lines.append(f"assign {CLK_ENABLE_SIGNAL_NAME}_B = 1;")
    else:
        dst.raw_lines.append(f"assign {CLK_ENABLE_SIGNAL_NAME}_B = ~{valid_output_name}_B | {valid_output_name}_A;")
    dst.raw_lines.append(f"wire divergent;")
    dst.raw_lines.append(f"assign divergent = ~({' & '.join(miter_names)});")
    dst.raw_lines.append(f"assign {UNSAFE_SINGAL_NAME} = {valid_output_name}_A & {valid_output_name}_B & divergent;")

    dst.raw_lines.append(f"{m_a.module_name}_A instance_A (")
    dst.raw_lines.append(f"    .{clock_input_name}({clock_input_name}),")
    dst.raw_lines.append(f"    .{CLK_ENABLE_SIGNAL_NAME}({CLK_ENABLE_SIGNAL_NAME}_A),")
    for name in normal_input_names:
        dst.raw_lines.append(f"    .{name}({name}),")
    for name in normal_output_names:
        dst.raw_lines.append(f"    .{name}({name}_A),")
    dst.raw_lines.append(f"    .{valid_output_name}({valid_output_name}_A)")
    dst.raw_lines.append(");")

    dst.raw_lines.append(f"{m_b.module_name}_B instance_B (")
    dst.raw_lines.append(f"    .{clock_input_name}({clock_input_name}),")
    dst.raw_lines.append(f"    .{CLK_ENABLE_SIGNAL_NAME}({CLK_ENABLE_SIGNAL_NAME}_B),")
    for name in normal_input_names:
        dst.raw_lines.append(f"    .{name}({name}),")
    for name in normal_output_names:
        dst.raw_lines.append(f"    .{name}({name}_B),")
    dst.raw_lines.append(f"    .{valid_output_name}({valid_output_name}_B)")
    dst.raw_lines.append(");")

    dst.raw_lines.append("endmodule")
    dst.parse_modules()
    return dst


def kairos_preprocess(src_file_1: str, src_file_2: str, dst_file: str, fast_slow_mode: bool) -> str:
    "Main verilog-to-verilog preprocess for kairos-style equivalence checking. Returns top-level module name."
    src_1 = VerilogFile()
    src_1.read_from_file(src_file_1)
    middle_1 = add_clk_enable_signal(remove_reset_signal(merge_valid_signals(src_1)))
    src_2 = VerilogFile()
    src_2.read_from_file(src_file_2)
    middle_2 = add_clk_enable_signal(remove_reset_signal(merge_valid_signals(src_2)))
    dst = construct_kairos(middle_1, middle_2, fast_slow_mode)
    dst.write_to_file(dst_file)
    return dst.modules[-1].module_name


def avr_preprocess(src_file: str, dst_file: str):
    "Adjustments for the AVR program."
    src = VerilogFile()
    src.read_from_file(src_file)
    line_number = src.modules[-1].end_line
    dst = VerilogFile()
    dst.raw_lines = src.raw_lines[:line_number] + [
        f"wire prop = !{UNSAFE_SINGAL_NAME};",
        "wire prop_neg = !prop;",
        "assert property ( prop );",
    ] + src.raw_lines[line_number:]
    dst.write_to_file(dst_file)


def remove_nondeterminism(src: VerilogFile) -> VerilogFile:
    "Remove nondeterminism by changing all `'bx`s to `'b0`s."
    dst = VerilogFile()
    dst.raw_lines.append("// Processed by function `remove_nondeterminism` in `verilog_tricks.py`.")
    dst.raw_lines.extend(line.replace("'bx", "'b0") for line in src.raw_lines)
    dst.parse_modules()
    return dst


def split_fsm_into_bits(src: VerilogFile) -> VerilogFile:
    "Split FSM registers into bits, so that they are checked more efficiently by our tools."
    dst = VerilogFile()
    dst.raw_lines.append("// Processed by function `split_fsm_into_bits` in `verilog_tricks.py`.")

    curr_fsm_name = None
    curr_fsm_width = None
    curr_fsm_bit_names = None
    for line in src.raw_lines:
        if "reg " in line and "_CS_fsm" in line:  # FSM register definition
            tokens = line.split()
            assert tokens[-1][-1] == ";"
            curr_fsm_name = tokens[-1][:-1]  # remove the semicolon
            assert tokens[-2][0] == "[" and tokens[-2][-3:] == ":0]"
            curr_fsm_width = int(tokens[-2][1:-3]) + 1  # e.g. "[3:0]"[1:-3] == "3"
            assert curr_fsm_width > 1
            curr_fsm_bit_names = [f"{curr_fsm_name}_bit_{i}" for i in range(curr_fsm_width)]
            for bit_name in curr_fsm_bit_names:
                dst.raw_lines.append(f"reg {bit_name};")
            dst.raw_lines.append(line.replace("reg ", "wire "))
            dst.raw_lines.append(f"assign {curr_fsm_name} = {{ {', '.join(reversed(curr_fsm_bit_names))} }};")
        elif f"{curr_fsm_name} = " in line:  # FSM register initialization
            tokens = line.split()
            time_label, name, equal_sign, value = tokens
            assert time_label == "#0" and name == curr_fsm_name and equal_sign == "="
            assert "'d" in value and value[-1] == ";"  # e.g. "3'd1;"
            int_value = int(value[value.find("'d") + 2:-1])
            bit_values = [(int_value >> i) & 1 for i in range(curr_fsm_width)]
            for bit_name, bit_value in zip(curr_fsm_bit_names, bit_values):
                dst.raw_lines.append(f"{time_label} {bit_name} = 1'b{bit_value};")
        elif f"{curr_fsm_name} <= " in line:  # FSM register update
            tokens = line.split()
            name, assign_sign, value = tokens
            assert name == curr_fsm_name and assign_sign == "<="
            assert value[-1] == ";" and not value[0].isdigit()
            for i, bit_name in enumerate(curr_fsm_bit_names):
                dst.raw_lines.append(f"{bit_name} <= {value[:-1]}[{i}];")
        else:
            dst.raw_lines.append(line)

    dst.parse_modules()
    return dst


def ours_preprocess(src_file: str, dst_file: str):
    "Main verilog-to-verilog preprocess for files in our equivalence checker."
    src = VerilogFile()
    src.read_from_file(src_file)
    dst = split_fsm_into_bits(remove_nondeterminism(remove_reset_signal(merge_valid_signals(src))))
    dst.write_to_file(dst_file)


def change_vivado_width(src_file: str, dst_file: str, src_width: int, dst_width: int):
    "helper function to change the word width of a vivado-generated verilog file"
    with open(src_file, "r") as f:
        lines = f.readlines()

    to_find = f"[{src_width-1}:0]"
    to_replace = f"[{dst_width-1}:0]"
    fsm_str = "_fsm"

    new_lines = []
    for line in lines:
        if fsm_str in line: # don't change FSM width
            new_lines.append(line)
        else:
            new_lines.append(line.replace(to_find, to_replace))

    with open(dst_file, "w") as f:
        f.writelines(new_lines)
