def _is_clock_signal(name: str):
    "heuristic to determine if a signal is a clock"
    return name.endswith("_clk")

def _is_reset_signal(name: str):
    "heuristic to determine if a signal is a reset"
    return name.endswith("_rst")

def _is_valid_signal(name: str):
    "heuristic to determine if a signal is a valid"
    return name.endswith("_vld")


class VerilogModule:
    """
    Interal representation of a verilog module.
    Assumes all fields to be fully constructed.
    """
    module_name: str
    start_line: int
    end_line: int
    port_end_line: int

    clock_input_name: str
    clock_enable_input_name: str
    reset_input_name: str
    normal_input_names: list[str]

    valid_output_name: str
    normal_output_names: list[str]

    name_to_width: dict[str, int]

    def __init__(self):
        self.normal_input_names = []
        self.normal_output_names = []
        self.name_to_width = {}


class VerilogFile:
    """
    Interal representation of a verilog file.
    The file is assumed to be generated by Vivado, thus neatly formatted.
    """
    raw_lines: list[str]
    "Lines of the verilog file without `\\n`."
    modules: list[VerilogModule]
    "A list of modules in the file."

    def __init__(self):
        self.raw_lines = []
        self.modules = []

    def read_from_file(self, path: str):
        "read/reload the verilog file from disk."
        self.raw_lines = []
        with open(path) as f:
            for line in f:
                assert line.endswith("\n")
                self.raw_lines.append(line[:-1])  # remove `\n`
        self.parse_modules()

    def parse_modules(self):
        "Fill up `self.modules` given `self.raw_lines`."
        self.modules = []
        curr_module = None
        for i, line in enumerate(self.raw_lines):
            if line.startswith("module "):
                curr_module = VerilogModule()
                curr_module.start_line = i
                curr_module.module_name = line.split()[1]
            elif line.startswith("endmodule"):
                curr_module.end_line = i
                self.modules.append(curr_module)
            elif line.startswith("input "):  # assume one line per input
                last_token = line.split()[-1]
                assert last_token.endswith(";")
                name = last_token[:-1]
                if _is_clock_signal(name):
                    curr_module.clock_input_name = name
                elif _is_reset_signal(name):
                    curr_module.reset_input_name = name
                elif name == CLK_ENABLE_SIGNAL_NAME:
                    curr_module.clock_enable_input_name = name
                else:
                    curr_module.normal_input_names.append(name)
                second_token = line.split()[1]
                if second_token.startswith("["):
                    assert second_token.endswith(":0]")
                    width = int(second_token[1:-3]) + 1
                    curr_module.name_to_width[name] = width
                else:
                    curr_module.name_to_width[name] = 1
            elif line.startswith("output "):  # assume one line per output
                last_token = line.split()[-1]
                assert last_token.endswith(";")
                name = last_token[:-1]
                if _is_valid_signal(name):
                    curr_module.valid_output_name = name
                else:
                    curr_module.normal_output_names.append(name)
                second_token = line.split()[1]
                if second_token.startswith("["):
                    assert second_token.endswith(":0]")
                    width = int(second_token[1:-3]) + 1
                    curr_module.name_to_width[name] = width
                else:
                    curr_module.name_to_width[name] = 1
            elif line.startswith(");"):
                curr_module.port_end_line = i

    def write_to_file(self, path: str):
        "Write the verilog file back to disk."
        with open(path, "w") as f:
            for line in self.raw_lines:
                f.write(line + "\n")


def remove_reset_signal(src: VerilogFile) -> VerilogFile:
    "Remove reset signal from every module in `src`, setting them to constant zero."
    dst = VerilogFile()
    dst.raw_lines.append("// Processed by function `remove_reset_signal` in `verilog_tricks.py`.")
    curr_module_index = 0
    curr_src_line_index = 0

    while curr_src_line_index < len(src.raw_lines):
        # start of a module:
        if curr_module_index < len(src.modules) and curr_src_line_index == src.modules[curr_module_index].start_line:
            m = src.modules[curr_module_index]
            while curr_src_line_index <= m.port_end_line:
                line = src.raw_lines[curr_src_line_index]
                if m.reset_input_name not in line:
                    dst.raw_lines.append(line)  # skip the reset input
                curr_src_line_index += 1
            while curr_src_line_index <= m.end_line:
                line = src.raw_lines[curr_src_line_index]
                if line.startswith("input ") and m.reset_input_name in line: 
                    dst.raw_lines.append(line.replace("input ", "wire "))  # change reset signal to wire
                    dst.raw_lines.append(f"assign {m.reset_input_name} = 1'b0;")  # assign reset to constant 0
                else:
                    dst.raw_lines.append(line)
                curr_src_line_index += 1
            curr_module_index += 1
        else: # outside of a module, just copy the lines:
            dst.raw_lines.append(src.raw_lines[curr_src_line_index])
            curr_src_line_index += 1
    dst.parse_modules()
    return dst


CLK_ENABLE_SIGNAL_NAME = "clk_enable"
def add_clk_enable_signal(src: VerilogFile) -> VerilogFile:
    "Add a clock enable signal to every module in `src`, as an alternative to clock gating."
    dst = VerilogFile()
    dst.raw_lines.append("// Processed by function `add_clk_enable_signal` in `verilog_tricks.py`.")
    curr_module_index = 0
    curr_src_line_index = 0

    while curr_src_line_index < len(src.raw_lines):
        # start of a module:
        if curr_module_index < len(src.modules) and curr_src_line_index == src.modules[curr_module_index].start_line:
            m = src.modules[curr_module_index]
            while curr_src_line_index < m.port_end_line:
                dst.raw_lines.append(src.raw_lines[curr_src_line_index])
                curr_src_line_index += 1
            dst.raw_lines[-1] = dst.raw_lines[-1] + ","   # fix port list
            dst.raw_lines.append(CLK_ENABLE_SIGNAL_NAME)  # add clk_enable signal to port list
            nested_level = 0
            in_always_block = False
            while curr_src_line_index <= m.end_line:      
                if curr_src_line_index == m.port_end_line + 1:
                    dst.raw_lines.append(f"input {CLK_ENABLE_SIGNAL_NAME};")  # add clk_enable signal as input
                line = src.raw_lines[curr_src_line_index]
                if line.startswith("always @ (posedge "):  # add clk_enable to every `always` block
                    assert m.clock_input_name in line and line.strip().endswith(") begin") and nested_level == 0
                    dst.raw_lines.append(line)
                    dst.raw_lines.append(f"if ({CLK_ENABLE_SIGNAL_NAME}) begin")
                    nested_level += 1
                    in_always_block = True
                else:
                    tokens = line.strip().split()
                    if "begin" in tokens:
                        nested_level += 1
                    if "end" in tokens:
                        nested_level -= 1
                        if nested_level == 0 and in_always_block:
                            dst.raw_lines.append("end")
                            in_always_block = False
                    dst.raw_lines.append(line)
                curr_src_line_index += 1
            assert nested_level == 0 and not in_always_block
            curr_module_index += 1
        else: # outside of a module, just copy the lines:
            dst.raw_lines.append(src.raw_lines[curr_src_line_index])
            curr_src_line_index += 1
    dst.parse_modules()
    return dst


def _wire_str(name: str, width_map: dict[str, int]) -> str:
    width = width_map[name]
    if width == 1:
        return name
    else:
        return f"[{width-1}:0] {name}"

UNSAFE_SINGAL_NAME = "unsafe_signal"
def construct_kairos(src_a: VerilogFile, src_b: VerilogFile) -> VerilogFile:
    "Constructs a product machine for equivalence checking in the Kairos fashion."
    dst = VerilogFile()
    dst.raw_lines.append("// Processed by function `construct_kairos` in `verilog_tricks.py`.")
    assert len(src_a.modules) == 1 and len(src_b.modules) == 1
    m_a, m_b = src_a.modules[0], src_b.modules[0]
    assert m_a.clock_input_name == m_b.clock_input_name
    assert m_a.valid_output_name == m_b.valid_output_name
    assert sorted(m_a.normal_input_names) == sorted(m_b.normal_input_names)
    assert sorted(m_a.normal_output_names) == sorted(m_b.normal_output_names)

    dst.raw_lines.append("// Machine A:")
    for line in src_a.raw_lines:
        if line.startswith("module "):
            line = f"module {m_a.module_name}_A ("  # rename module
        dst.raw_lines.append(line)
    dst.raw_lines.append("")
    dst.raw_lines.append("// Machine B:")
    for line in src_b.raw_lines:
        if line.startswith("module "):
            line = f"module {m_b.module_name}_B ("  # rename module
        dst.raw_lines.append(line)
    dst.raw_lines.append("")
    dst.raw_lines.append("// Product machine:")

    width_map = m_a.name_to_width
    normal_input_names = m_a.normal_input_names
    normal_output_names = m_a.normal_output_names
    clock_input_name = m_a.clock_input_name
    valid_output_name = m_a.valid_output_name

    ports = normal_input_names + [clock_input_name, UNSAFE_SINGAL_NAME]
    dst.raw_lines.append(f"module {m_a.module_name}_A_times_{m_b.module_name}_B ({', '.join(ports)});")
    for name in normal_input_names:
        dst.raw_lines.append(f"input {_wire_str(name, width_map)};")
    dst.raw_lines.append(f"input {clock_input_name};")
    dst.raw_lines.append(f"output {UNSAFE_SINGAL_NAME};")

    miter_names = []
    for name in normal_output_names:
        dst.raw_lines.append(f"wire {_wire_str(name, width_map)}_A;")
        dst.raw_lines.append(f"wire {_wire_str(name, width_map)}_B;")
        dst.raw_lines.append(f"wire {name}_eq;")
        dst.raw_lines.append(f"assign {name}_eq = {name}_A == {name}_B;")
        miter_names.append(f"{name}_eq")
    dst.raw_lines.append(f"wire {valid_output_name}_A;")
    dst.raw_lines.append(f"wire {valid_output_name}_B;")
    dst.raw_lines.append(f"wire {CLK_ENABLE_SIGNAL_NAME}_A;")
    dst.raw_lines.append(f"wire {CLK_ENABLE_SIGNAL_NAME}_B;")
    dst.raw_lines.append(f"assign {CLK_ENABLE_SIGNAL_NAME}_A = ~{valid_output_name}_A | {valid_output_name}_B;")
    dst.raw_lines.append(f"assign {CLK_ENABLE_SIGNAL_NAME}_B = ~{valid_output_name}_B | {valid_output_name}_A;")
    dst.raw_lines.append(f"wire divergent;")
    dst.raw_lines.append(f"assign divergent = ~({' & '.join(miter_names)});")
    dst.raw_lines.append(f"assign {UNSAFE_SINGAL_NAME} = {valid_output_name}_A & {valid_output_name}_B & divergent;")

    dst.raw_lines.append(f"{m_a.module_name}_A instance_A (")
    dst.raw_lines.append(f"    .{clock_input_name}({clock_input_name}),")
    dst.raw_lines.append(f"    .{CLK_ENABLE_SIGNAL_NAME}({CLK_ENABLE_SIGNAL_NAME}_A),")
    for name in normal_input_names:
        dst.raw_lines.append(f"    .{name}({name}),")
    for name in normal_output_names:
        dst.raw_lines.append(f"    .{name}({name}_A),")
    dst.raw_lines.append(f"    .{valid_output_name}({valid_output_name}_A)")
    dst.raw_lines.append(");")

    dst.raw_lines.append(f"{m_b.module_name}_B instance_B (")
    dst.raw_lines.append(f"    .{clock_input_name}({clock_input_name}),")
    dst.raw_lines.append(f"    .{CLK_ENABLE_SIGNAL_NAME}({CLK_ENABLE_SIGNAL_NAME}_B),")
    for name in normal_input_names:
        dst.raw_lines.append(f"    .{name}({name}),")
    for name in normal_output_names:
        dst.raw_lines.append(f"    .{name}({name}_B),")
    dst.raw_lines.append(f"    .{valid_output_name}({valid_output_name}_B)")
    dst.raw_lines.append(");")

    dst.raw_lines.append("endmodule")
    dst.parse_modules()
    return dst


def kairos_preprocess(src_file_1: str, src_file_2: str, dst_file: str) -> str:
    "Main verilog-to-verilog preprocess for kairos-style equivalence checking. Returns top-level module name."
    src_1 = VerilogFile()
    src_1.read_from_file(src_file_1)
    middle_1 = add_clk_enable_signal(remove_reset_signal(src_1))
    src_2 = VerilogFile()
    src_2.read_from_file(src_file_2)
    middle_2 = add_clk_enable_signal(remove_reset_signal(src_2))
    dst = construct_kairos(middle_1, middle_2)
    dst.write_to_file(dst_file)
    return dst.modules[-1].module_name


def avr_preprocess(src_file: str, dst_file: str):
    "Adjustments for the AVR program."
    src = VerilogFile()
    src.read_from_file(src_file)
    line_number = src.modules[-1].end_line
    dst = VerilogFile()
    dst.raw_lines = src.raw_lines[:line_number] + [
        f"wire prop = !{UNSAFE_SINGAL_NAME};",
        "wire prop_neg = !prop;",
        "assert property ( prop );",
    ] + src.raw_lines[line_number:]
    dst.write_to_file(dst_file)


def remove_nondeterminism(src: VerilogFile) -> VerilogFile:
    "Remove nondeterminism by changing all `'bx`s to `'b0`s."
    dst = VerilogFile()
    dst.raw_lines.append("// Processed by function `remove_nondeterminism` in `verilog_tricks.py`.")
    dst.raw_lines.extend(line.replace("'bx", "'b0") for line in src.raw_lines)
    dst.parse_modules()
    return dst


def ours_preprocess(src_file: str, dst_file: str):
    "Main verilog-to-verilog preprocess for files in our equivalence checker."
    src = VerilogFile()
    src.read_from_file(src_file)
    dst = remove_nondeterminism(remove_reset_signal(src))
    dst.write_to_file(dst_file)
