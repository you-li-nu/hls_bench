--------------------------------------------------------------------------------
--
--   AMD2910 Benchmark
--
-- Source:  AMD data book
--
-- author: Indraneel Ghosh
--         University Of California, Irvine, CA 92717
--
-- Written on Feb19, 1992
--
--------------------------------------------------------------------------------


TESTING THE Am2910 MODELS.

 PORTS 

		I : in
		CCEN_BAR : in
		CC_BAR : in 
		RLD_BAR : in
		CI : in
		OEbar : in 
		clk : in 
		D : in 
		Y : out
		PL_BAR : out
		VECT_BAR : out 
		MAP_BAR : out 
		FULL_BAR : out

 Details about these ports are mentioned in the "am2910.doc" file.

 OVERALL TESTING STRATEGY 

 In testing the Am2910 models, the overall strategy adopted is to 
 test each "hardware" component (e.g. stack, register/counter etc.)  using
 sequences of test vectors.

 The components are tested in different modes with test vectors designed
 to detect "stuck-at-0" and "stuck-at-1" faults at various points in the 
 hardware. 

 Because the components are not being tested in isolation, we need to
 set up input values at input ports of the chip and propagate them to 
 the input of that component. Also, the output of a component has to
 be propagated to the output ports of the chip.

 So, an error indication generated while running the test vectors for a 
 particular component might result from faults in other components that
 are in the propagation paths.

 However, the overall error indication pattern, generated by the simulation,
 will provide a better pointer to the location of the fault. It will exclude 
 some possible fault locations, in most cases.

 TESTING THE COMPONENTS

 Now, we discuss the testing of the individual components.

**************************
*	                 *
* TEST VECTORS FOR STACK *
*       	         *
**************************

 In testing the stack ( which has five levels of nesting), we push five 
 different words into the stack and monitor the word at the top of the
 stack and the FULL_BAR signal in each case. 

 Then we do five pops and again monitor the word at the top of the stack
 and the FULL_BAR signal at each stage. 

 To test for stuck-at faults in each stack location, we then repeat the
 above test with five words that are Boolean complements of the ones 
 used in the above test.

 We also, test for each set of conditions ( instruction, condition code
 and register/counter value) that causes a PUSH or a POP.

*************************************
*	                            *
* TEST VECTORS FOR REGISTER COUNTER *
*       	         	    *
*************************************

 Now, we test for stuck-at faults in the register/counter and its control 
 logic.

******* TEST LOADING OPERATION (INSTRUCTION) ******* 

 To test loading operations, we load all 1's and all 0's, for each set of
 conditions ( instruction, condition code and register/counter value) that 
 causes a load operation.

******* TEST LOADING OPERATION (RLD_BAR) ******* 

 To test loading operations when signal RLD_BAR is asserted, we load all 1's
 and all 0's into the register/counter. 

******* TEST DECREMENT OPERATION ********

 To test decrement operations, we perform one decrement operation, for each
 set of conditions ( instruction, condition code and register/counter value)
 that causes a decrement operation.

******* TEST DECREMENT OPERATION BORROW RIPPLE ******* 

 We run test vectors to test the rippling of borrow through each of the 
 12 bits in the decrement operation.

*****************************************
*	                                *
* TEST VECTORS FOR MICROPROGRAM COUNTER *
*       	         	        *
*****************************************

 Now, we test for stuck-at faults in the microprogram counter and its control 
 logic.

******* TEST CLEARING OPERATION ********

 We test the clearing operation of the uPC under all the relevant conditions.

******* TEST LOADING OPERATION ********

 We load all 0's and all 1's to test for stuck at faults.

******* TEST INCREMENT CARRY RIPPLE ********

 We run test vectors to test the rippling of carry through each of the 
 12 bits in the increment operation.

********************************
*	                       *
* TEST VECTORS FOR MULTIPLEXER *
*              	               *
********************************

 We run test vectors to test for stuck-at-0 and stuck-at-1 faults under 
 all the relevant set of conditions (instruction, condition code, 
 register/counter value) in the following cases :

MULTIPLEXER SELECTS 0 

MULTIPLEXER SELECTS D 

MULTIPLEXER SELECTS R

MULTIPLEXER SELECTS uPC

MULTIPLEXER SELECTS TOS

*************************************
*	                            *
* TEST VECTORS FOR TRI-STATE-DRIVER *
*              	                    *
*************************************

 We test the tri-stating of outputs under the control of signal OEbar.

*************************************
*	                            *
* TEST VECTORS FOR ENABLE SIGNALS   *
*              	                    *
*************************************

 We test the assertion of signals PL_BAR, VECT_BAR and MAP_BAR under 
 different sets of conditions ( instruction, condition code and 
 register/counter contents).