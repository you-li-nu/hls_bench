--------------------------------------------------------------------------------
--
--   AM2901 Benchmark
--
-- Source: AM2901 Data Book
--
-- author: Indraneel Ghosh
--         University Of California, Irvine, CA 92717
--
-- Written on Jan 1, 1992
--
--------------------------------------------------------------------------------

TESTING THE Am2901 MODELS.

 PORTS 

	I	input
	D	input
	Aadd	input
	Badd	input
	C0	input
	OEbar	input
	RAM0	input
	RAM3	input
	Q0	input
	Q3	input
	Y	output
	C4	output
	Gbar	output
	Pbar	output
	OVR	output
	F3	output
	F30	output
	RAM0	output
	RAM3	output
	Q0	output
	Q3	output

 Details about these ports are mentioned in the "am2901.doc" file.

 OVERALL TESTING STRATEGY 

 In testing the Am2901 models, the overall strategy adopted is to 
 test each "hardware" component (e.g. alu, RAM etc.)  using
 sequences of test vectors.

 The components are tested in different modes with test vectors designed
 to detect "stuck-at-0" and "stuck-at-1" faults at various points in the 
 hardware. 

 Paths are also tested for "stuck-at-0" and "stuck-at-1" faults at any 
 point on the path. Paths start at some register (or external data input),
 go through the ALU and end at a register.

 Because the components are not being tested in isolation, we need to
 set up input values at input ports of the chip and propagate them to 
 the input of that component. Also, the output of a component has to
 be propagated to the output ports of the chip.

 So, an error indication generated while running the test vectors for a 
 particular component might result from faults in other components that
 are in the propagation paths.

 However, the overall error indication pattern, generated by the simulation,
 will provide a better pointer to the location of the fault. It will exclude 
 some possible fault locations, in most cases.

 TESTING THE COMPONENTS

 Now, we discuss the testing of the individual components.

************************
*                      *
* TEST VECTORS FOR ALU *
*                      *
************************

 Each of the eight functions of the 4-bit alu is individually tested.
 The function to be selected depends on the value of ( I5 I4 I3 ).
 In all cases, each bit of the 4-bit functional unit is tested for
 "stuck-at-0" and "stuck-at-1" faults.

   ADDITION  R + S : Each of the 4 full-adders is tested for "stuck-at-0" 
  		     and "stuck-at-1" faults. So each full adder gets each
		     of the inputs (0,0) (0,1) (1,1) (1,0) at least once 
 		     and both the sum and carry values are checked, along 
                     with the other ALU status signals OVR, F3, F30, P_bar,
                     G_bar. This sort of testing is done with both values 
		     of carry-in C0.

		     To test the carry propagation in each of the 4 full
                     adders, 4 additional test vectors are used.

 SUBTRACTION S - R : Each of the 4 full-adders is tested for "stuck-at-0" 
	             and "stuck-at-1" faults. So each full adder gets each
       		     of the inputs (0,0) (0,1) (1,1) (1,0) at least once 
 		     and both the sum and borrow values are checked, along 
                     with the other ALU status signals OVR, F3, F30, P_bar,
                     G_bar. This sort of testing is done with both values 
		     of borrow-in C0.

		     To test the borrow propagation in each of the 4 full
                     adders, 4 additional test vectors are used.

 SUBTRACTION R - S : Each of the 4 full-adders is tested for "stuck-at-0" 
	             and "stuck-at-1" faults. So each full adder gets each
       		     of the inputs (0,0) (0,1) (1,1) (1,0) at least once 
 		     and both the sum and borrow values are checked, along 
                     with the other ALU status signals OVR, F3, F30, P_bar,
                     G_bar. This sort of testing is done with both values 
		     of borrow-in C0.

		     To test the borrow propagation in each of the 4 full
                     adders, 4 additional test vectors are used.
                     
       OR (R or S) : Each of the 4 OR gates is tested for "stuck-at-0"
		     and "stuck-at-1" faults with inputs (0,0) (0,1) (1,1)
		     (1,0).

     AND (R and S) : Each of the 4 AND gates is tested for "stuck-at-0"
		     and "stuck-at-1" faults with inputs (0,0) (0,1) (1,1)
		     (1,0).

AND (not(R) and S) : Each of the 4 AND gates is tested for "stuck-at-0"
		     and "stuck-at-1" faults with inputs (0,0) (0,1) (1,1)
		     (1,0).

     XOR (R xor S) : Each of the 4 XOR gates is tested for "stuck-at-0"
		     and "stuck-at-1" faults with inputs (0,0) (0,1) (1,1)
		     (1,0).

   XNOR (R xnor S) : Each of the 4 XNOR gates is tested for "stuck-at-0"
		     and "stuck-at-1" faults with inputs (0,0) (0,1) (1,1)
		     (1,0).

************************
*                      *		
* TEST VECTORS FOR RAM *
*                      *
************************

 The RAM has 16 memory locations which are 4-bits wide. It also has an
 up/down shifter at its input. It has two ports A and B. The address 
 at port A is only for reading. The address at B port is for reading 
 and writing. 

WRITING 0's AND 1's 
  IN RAM LOCATIONS : Each memory location has all 0's and all 1's 
   		     written in it using the B port address. The 
		     location written to is then read using the
		     A port. It is read again using the B port.
		     This tests for "stuck-at" faults in all 
		     memory locations and ports.

TESTING RAM 
          SHIFTERS : The up shift and down shift operations are
		     tested by shifting a '0' and then a '1' in
		     each case. In one test vector a '0' is shifted
		     in and a '1' is shifted out. In another test 
    		     vector, its vice versa. 

		     Since, two values of ( I8 I7 I6 ) cause
		     an up-shift operation and two cause a down
		     shift operation, all these test vectors are
		     executed once for each value.

*******************************		
*                             *
* TEST VECTORS FOR Q-REGISTER *
*                             *
*******************************

 The Q register is 4-bits wide and has an up/down shifter at its 
 input. 

WRITING 0's AND 1's : All 0's and all 1's are written to the 
		      Q-register and then read from it to 
		      check for "stuck-at" faults.

TESTING Q-REGISTER
           SHIFTERS : The up shift and down shift operations are
       		      tested by shifting a '0' and then a '1' in
		      each case. In one test vector a '0' is shifted
		      in and a '1' is shifted out. In another test 
    		      vector, its vice versa. 

		      Since, two values of ( I8 I7 I6 ) cause
		      an up-shift operation and two cause a down
		      shift operation, all these test vectors are
		      executed once for each value.

****************************************
*                                      *
* TEST VECTORS FOR ALU SOURCE-SELECTOR *
*                                      *
****************************************

 The ALU source-selector has 8 modes of operation depending on the 
 value of ( I2 I1 I0 ). In each mode, sources are selected for the
 2 ALU inputs. 

 TESTING FOR ALU SOURCE-SELECT ( R = A, S = Q) : 		
 Test vectors use all 0's and all 1's for the selected sources of
 ALU inputs to check for "stuck-at" faults.

 TESTING FOR ALU SOURCE-SELECT ( R = A, S = B) : 		
 Test vectors use all 0's and all 1's for the selected sources of
 ALU inputs to check for "stuck-at" faults.

 TESTING FOR ALU SOURCE-SELECT ( R = 0, S = Q) : 		
 Test vectors use all 0's and all 1's for the selected sources of
 ALU inputs to check for "stuck-at" faults.

 TESTING FOR ALU SOURCE-SELECT ( R = 0, S = B) : 		
 Test vectors use all 0's and all 1's for the selected sources of
 ALU inputs to check for "stuck-at" faults.

 TESTING FOR ALU SOURCE-SELECT ( R = 0, S = A) : 		
 Test vectors use all 0's and all 1's for the selected sources of
 ALU inputs to check for "stuck-at" faults.

 TESTING FOR ALU SOURCE-SELECT ( R = D, S = A) : 		
 Test vectors use all 0's and all 1's for the selected sources of
 ALU inputs to check for "stuck-at" faults.

 TESTING FOR ALU SOURCE-SELECT ( R = D, S = Q) : 		
 Test vectors use all 0's and all 1's for the selected sources of
 ALU inputs to check for "stuck-at" faults.

 TESTING FOR ALU SOURCE-SELECT ( R = D, S = 0) : 		
 Test vectors use all 0's and all 1's for the selected sources of
 ALU inputs to check for "stuck-at" faults.

************************************
*                                  *
* TEST VECTORS FOR OUTPUT-SELECTOR *
*                                  *
************************************

 The ALU output selector selects the output according to the value
 of ( I8 I7 I6 ). So, it has 8 modes of operation.

 TESTING OUTPUT FOR (I8 I7 I6 = 000) : Test for "stuck-at" faults 
				       using all 0's and all 1's.
				       Also, test for the case when
				       output is tristated.

 TESTING OUTPUT FOR (I8 I7 I6 = 001) : Test for "stuck-at" faults 
				       using all 0's and all 1's.
				       Also, test for the case when
				       output is tristated. 		

 TESTING OUTPUT FOR (I8 I7 I6 = 010) : Test for "stuck-at" faults 
				       using all 0's and all 1's.
				       Also, test for the case when
				       output is tristated.

 TESTING OUTPUT FOR (I8 I7 I6 = 011) : Test for "stuck-at" faults 
				       using all 0's and all 1's.
				       Also, test for the case when
				       output is tristated.

 TESTING OUTPUT FOR (I8 I7 I6 = 100) : Test for "stuck-at" faults 
				       using all 0's and all 1's.
				       Also, test for the case when
				       output is tristated.

 TESTING OUTPUT FOR (I8 I7 I6 = 101) : Test for "stuck-at" faults 
				       using all 0's and all 1's.
				       Also, test for the case when
				       output is tristated.

 TESTING OUTPUT FOR (I8 I7 I6 = 110) : Test for "stuck-at" faults 
				       using all 0's and all 1's.
				       Also, test for the case when
				       output is tristated.

 TESTING OUTPUT FOR (I8 I7 I6 = 111) : Test for "stuck-at" faults 
				       using all 0's and all 1's.
				       Also, test for the case when
				       output is tristated.

**************************
*                        *
* TEST VECTORS FOR PATHS *
*                        *
**************************

 Paths start at some register (or external data input), go through the ALU
 and end at a register.

 We can classify paths into 2 types :
   -- Those that end at the Q-register
   -- Those that end at the RAM

*** TESTING PATHS ( "ALU-SOURCES" --> F --> Q ) ***

 These are the paths that end at the Q-register. There are 8 types of 
 paths depending on the ALU sources they start at :-

PATH TEST WITH ALU-SOURCE ( R = A , S = Q ) : The path is tested for
					      "stuck-at" faults at any 
					      point using all 1's and 
					      all 0's.

PATH TEST WITH ALU-SOURCE ( R = A , S = B ) : The path is tested for
					      "stuck-at" faults at any 
					      point using all 1's and 
					      all 0's.

PATH TEST WITH ALU-SOURCE ( R = 0 , S = Q ) : The path is tested for
					      "stuck-at" faults at any 
					      point using all 1's and 
					      all 0's.

PATH TEST WITH ALU-SOURCE ( R = 0 , S = B ) : The path is tested for
					      "stuck-at" faults at any 
					      point using all 1's and 
					      all 0's.

PATH TEST WITH ALU-SOURCE ( R = 0 , S = A ) : The path is tested for
					      "stuck-at" faults at any 
					      point using all 1's and 
					      all 0's.

PATH TEST WITH ALU-SOURCE ( R = D , S = A ) : The path is tested for
					      "stuck-at" faults at any 
					      point using all 1's and 
					      all 0's.

PATH TEST WITH ALU-SOURCE ( R = D , S = Q ) : The path is tested for
					      "stuck-at" faults at any 
					      point using all 1's and 
					      all 0's.

PATH TEST WITH ALU-SOURCE ( R = D , S = 0 ) : The path is tested for
					      "stuck-at" faults at any 
					      point using all 1's and 
					      all 0's.

PATH TEST WITH ALU-SOURCE ( R = D , S = 0 ) : The path is tested for
					      "stuck-at" faults at any 
					      point using all 1's and 
					      all 0's.

*** TESTING PATHS ( "ALU-SOURCES" --> F --> B ) ***

 These are the paths that end at the RAM. There are 8 types of 
 paths depending on the ALU sources they start at :-

PATH TEST WITH ALU-SOURCE ( R = A , S = Q ) : The path is tested for
					      "stuck-at" faults at any 
					      point using all 1's and 
					      all 0's.

PATH TEST WITH ALU-SOURCE ( R = A , S = B ) : The path is tested for
					      "stuck-at" faults at any 
					      point using all 1's and 
					      all 0's.

PATH TEST WITH ALU-SOURCE ( R = 0 , S = Q ) : The path is tested for
					      "stuck-at" faults at any 
					      point using all 1's and 
					      all 0's.

PATH TEST WITH ALU-SOURCE ( R = 0 , S = B ) : The path is tested for
					      "stuck-at" faults at any 
					      point using all 1's and 
					      all 0's.

PATH TEST WITH ALU-SOURCE ( R = 0 , S = A ) : The path is tested for
					      "stuck-at" faults at any 
					      point using all 1's and 
					      all 0's.

PATH TEST WITH ALU-SOURCE ( R = D , S = A ) : The path is tested for
					      "stuck-at" faults at any 
					      point using all 1's and 
					      all 0's.

PATH TEST WITH ALU-SOURCE ( R = D , S = Q ) : The path is tested for
					      "stuck-at" faults at any 
					      point using all 1's and 
					      all 0's.

PATH TEST WITH ALU-SOURCE ( R = D , S = 0 ) : The path is tested for
					      "stuck-at" faults at any 
					      point using all 1's and 
					      all 0's.



